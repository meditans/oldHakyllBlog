---
title: A top-down lens tutorial
---
** Motivations
The joy of studying the lens library is twofold: on the practical side, lens is
a treasure of functions that can be a powerful tool in the hands of a haskeller.
On the other side, it's really a mind-bending library, and studying its working
expands our minds with possibilities.

Most of the tutorial around focus on the motivation and the construction of the
basic lens types. That's an important step to understand how things could be
constructed from scratch, but not necessarily the quickest way to understand the
library.

In this tutorial, we will follow another approach; we'll start from the most
general abstractions and work our way down to the more concrete types and
functions, trying to get both an intuition and ---

In what follows, I'll assume assume that you are familiar with the folklore
regarding lens, that is, that with them you can (at least) mitigate the record
problem and get getter/setter functionalies.

If you feel unsure about that, please read Gabriel's introductory post [[http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html][Program
imperatively using Haskell lenses]]

If you want a spoiler-free version of the lens world, and want to work out the
details, check Artyom's awesome series of posts [[http://artyom.me/lens-over-tea-1][Lenses over Tea]].

Also, before starting, you need to know what a profunctor is. You can read [[https://www.fpcomplete.com/user/liyang/profunctors][I love
profunctors. They're so easy]]. Go over and read it, I'll wait.

A note on why you should learn this type of abstractions when using lens. They
come up in the error messages! So if you query for the type of
src_haskell{enum}, you'll get a signature with some constraints, and decipher
what's the meaning between that function, constructing a useful mental model of
what it does.

So for every concept I'll try to give also a useful mental model.

The first thing you should know is profunctors. You can check this article, or
this previous article of mine. The gist of it is that a profunctor is a
bifunctor which is contravariant in the first argument and covariant in the
second, just like function. If this description feels too terse, go check the
article (there are pretty images).

So, profunctors. Profunctor generalize this specific behavior of functions:

Let's see how we can change some of the types of the function src_haskell{a->b}

| Result Type         | We need a           |
|---------------------+---------------------|
| src_haskell{a -> c} | src_haskell{b -> c} |
| src_haskell{c -> b} | src_haskell{c -> a} |

So, this is to say that functions, seen as bifunctors, are covariant in a type
and contravariant in the other. This is specifically the behavior we capture
with profunctors:

In fact here is a minimal definition:

#+BEGIN_SRC haskell
class Profunctor p where
  lmap :: (a -> b) -> p b c -> p a c
  rmap :: (b -> c) -> p a b -> p a c
#+END_SRC

(there is also a src_haskell{dimap} method, which combines the two functions).

So, why is this abstraction useful? Well, with this you can construct things
which behave like functions, but can have some proprieties more:

One of the most important examples is the src_haskell{Indexed} type in src_haskell{Control.Lens.Indexed}:
#+BEGIN_SRC haskell
newtype Indexed i a b = Indexed { runIndexed :: i -> a -> b }
#+END_SRC

So, this is a wrapper around the type src_haskell{i -> a -> b}, so src_haskell{Indexed i} is a
bifunctor which has the right variance properties in src_haskell{a} and src_haskell{b} to be a
profunctor.

With this we gain the ability to speak of functions which also discriminate over
an index.

Why, do you ask, should we care about profunctors? They let us unify two

Common types of profunctors. From src_haskell{Data.Profunctor}, we notice src_haskell{UpStar} and
src_haskell{DownStar}, to obtain profunctor from functors, src_haskell{WrappedArrow}, because it turns
out that arrows are profunctors, and, for the categorically inclined, the
src_haskell{Forget} profunctor.

** The overarching abstractions
The main thing to understand about the src_haskell{lens} library is that mostly
all abstractions derive from a common one:

#+BEGIN_SRC haskell
type Optical p q f s t a b = p a (f b) -> q s (f t)
#+END_SRC

What does it mean? An src_haskell{Optical} transforms a profunctor from
src_haskell{a} to src_haskell{f b} to a profunctor from src_haskell{s} to
src_haskell{f t}. One way or another, most of the functions in lens can be
arranged to fit this kind of pattern. What will change is the different choices
and constraints we'll make for profunctors, functors, and types.

So, for each type we're seeing, I'll give a couple of definitions with and
without referencing more general abstractions.

We might, for example, *use the same profunctor*:
#+BEGIN_SRC haskell
type Optic p f s t a b = p a (f b) -> p s (f t)
type Optic p f s t a b = Optical p p f s t a b
#+END_SRC

and constructing src_haskell{LensLike}, if we choose as a profunctor *the
simplest one:* src_haskell{(->)}!
#+BEGIN_SRC haskell
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike f s t a b = Optical (->) (->) f s t a b
#+END_SRC

Or, starting with an src_haskell{Optical}, we might mantain polymorphic only the
first profunctor; in this way we can trasform it in a function, to use later: As
the documentation says, "This is a convenient alias for use when you need to
consume either indexed or non-indexed lens-likes based on context."

#+BEGIN_SRC haskell
type Over p f s t a b = Optical p (->) f s t a b
type Over p f s t a b = p a (f b) -> (s -> f t)
#+END_SRC

if we pick an indexable profunctor we can define an indexedlenslike construction:
#+BEGIN_SRC haskell
type IndexedLensLike i f s t a b = forall p. Indexable i p => p a (f b) -> s -> f t 
#+END_SRC

Note the usage of src_haskell{forall p.}, which is granted by the src_haskell{Rank2Types} extension.
You can learn about RankNTypes [[https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html][at Oliver Charles' blog]].

** Lenses, folds, and traversals
Now, let's focus on the src_haskell{LensLike} construction, and specialize it to
the most known types of the lens ecosystem, just by *choosing different
constraints for our functor src_haskell{f}*.
#+BEGIN_SRC haskell
type Lens       s t a b = forall f. Functor f     => (a -> f b) -> s -> f t 
type Traversal  s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
type Traversal1 s t a b = forall f. Apply f       => (a -> f b) -> s -> f t
type Setter     s t a b = forall f. Settable f    => (a -> f b) -> s -> f t
#+END_SRC

It's useful to consider some mental model the functor instance is the most basic
one, and it gives rise to the src_haskell{Lens}; as a mental model, we should
think at something that can be used to read and set a particular location in a
data structure.

If we add the Applicative constraint, we are now able to edit more location,
with src_haskell{Traversal}.

If we just take the src_haskell{<*>} operator from src_haskell{Applicative}, but
not src_haskell{pure} (that's what the src_haskell{Apply} class does), we keep
the possibility of combining elements, but lose the possibility to talk of $0$
elements. So, with a src_haskell{Traversal1}, we can get and set one of more
elements in a data structure.

The src_haskell{Setter}, on the other hand, let you set things. The
src_haskell{Settable f} constraint is a fancy way to say that your
src_haskell{f} is isomorphic to identity, so you could say that
#+BEGIN_SRC haskell
Setter s t a b  (a -> b) -> (s -> t)
#+END_SRC

*** TODO If the type isn't varied
Now, if we pose $a = b$ and $s = t$, we can define:
#+BEGIN_SRC haskell
type Getter s a = forall f. (Contravariant f, Functor f)     => (a -> f a) -> s -> f s
type Fold   s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s 
type Fold1  s a = forall f. (Contravariant f, Apply f)       => (a -> f a) -> s -> f s
#+END_SRC

TODO: Explain why one wants the Contravariant constraint.

choosing a particular instance, we get (heh):
#+BEGIN_SRC haskell
type Getting r s a = (a -> Const r a) -> s -> Const r s
#+END_SRC

Note that every function can be a getter, and the connection is the Continuation passing style.
Note also the read only property (we choose the functor).

** Isomorphisms and Prisms

An equality between two things happens if they have the same "profunctor" and the same "functor".
#+BEGIN_SRC haskell
type Equality s t a b = forall p f. p a (f b) -> p s (f t)
#+END_SRC

In src_haskell{Iso} we also *add the constraints*:
#+BEGIN_SRC haskell
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
#+END_SRC

A prism is a restricted form of this idea, *with more constraints* (src_haskell{p} is
src_haskell{Choice}, and src_haskell{f} is src_haskell{Applicative})
#+BEGIN_SRC haskell
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
#+END_SRC

There are also src_haskell{Review} and src_haskell{AReview}, with their peculiar constraints choices.
#+BEGIN_SRC haskell
type Review t b  = forall p f. (Choice p, Bifunctor p, Settable f) => Optic' p f t b
type AReview t b = Optic' Tagged Identity t b 
#+END_SRC

** Conclusion
Now we explored the essential part of the module [[https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Type.html][Control.Lens.Type]]. As an
exercise, skim that module and make sure that you understand everything it's
going on there.

Remember, the main point to take home is the fact that the brilliance of this
library is understanding that all these types derive from a common abstraction:

Next time we'll skim briefly on the types of the most common functions, to get
an intuition for how we can use them. Till next time!
